package squid
package anf

import ir._

/**
  * Created by lptk on 03/02/17.
  */
@deprecated("", "") // this is to remove the warning generated by Abort() below, which we want to test even if it's deprecated.
// as an alternative solution, perhaps try the compiler plugin: https://github.com/ghik/silencer
class TransformationControlTests extends MyFunSuite(SimpleANFTests.DSL) {
  import DSL.Predef._
  
  import collection.mutable.ArrayBuffer
  
  test("Predef.Abort") {
    
    val c0 = code"val a = ArrayBuffer[Int](1,2,3); println(a(1)); a.size"
    def f(x: Code[_,{}]) = x rewrite {
      case code"val arr = ArrayBuffer[$t]($xs*); $body: $bt" =>
        body subs 'arr -> Abort()
    }
    f(c0) eqt c0
    f(code"val a = ArrayBuffer[Int](1,2,3); println('ok)") eqt code"println('ok)"
    
    intercept[IllegalAccessError](Abort()) // warns: method Abort in class Predef is deprecated: Abort(msg) should only be called from the body of a rewrite rule. If you want to abort a rewriting from a function called in the rewrite rule body, use `throw RewriteAbort(msg)` instead.
    
  }
  
  test("Predef.Return") {
    
    val a = code"println(12.toDouble); println(identity(42)+1); 666"
    val b = a rewrite {
      case code"($x:Int)+($y:Int)" =>
        Return(code"$x+$y")
      case code"(${Const(n)}:Int)" => Const(n+1)
    }
    
    // The `1` constant has not been incremented because it was part of the early return (43 was let-bound outisde of it)
    b eqt code"println(13.toDouble); println(identity(43)+1); 667"
    
  }
  
  test("Predef.Return.transforming trivial expression") {
    
    def f(rep: Code[_,{}]) = rep rewrite {
      case code"ArrayBuffer($x:Int,$y:Int)" =>
        Return.transforming(x)(x => code"ArrayBuffer($x,$y)")
      case code"(${Const(n)}:Int)" => Const(n+1)
    }
    
    f(code"ArrayBuffer(50,60)") eqt code"ArrayBuffer(51,60)"
    f(code"ArrayBuffer(50,60);println") eqt code"ArrayBuffer(51,60);println"
    f(code"val a = ArrayBuffer(50,60);println(a)") eqt code"val a = ArrayBuffer(51,60);println(a)"
    
     val a0 = code"ArrayBuffer(50,60,70)" rewrite {
      case code"ArrayBuffer[Int]($x,$y,$z)" =>
        Return.transforming(x,z)((x,z) => code"ArrayBuffer($x,$x,$y,$y,$z,$z)")
      case code"(${Const(n)}:Int)" => Const(n+1)
    }
    a0 eqt code"ArrayBuffer(51,51,60,60,71,71)"
    
     val a1 = code"ArrayBuffer(50,60,70)" rewrite {
      case code"ArrayBuffer[Int]($x,$y,$z)" =>
        //Return.transforming(x::z::Nil)(_ |>! {case x::z::Nil => ir"ArrayBuffer($x,$x,$y,$y,$z,$z)"}) // probably does not compile because of the patmat
        Return.transforming(x::z::Nil){ls => val x = ls(0); val z = ls(1); code"ArrayBuffer($x,$x,$y,$y,$z,$z)"}
      case code"(${Const(n)}:Int)" => Const(n+1)
    }
    a1 eqt code"ArrayBuffer(51,51,60,60,71,71)"
    
  }
  
  test("Predef.Return.transforming blocks") {
    
    {
      val a = code"println; println(if(true) println(42.toDouble) else println(666.toDouble))"
      val b = a rewrite {
        case code"if($cond)$thn else $els: $t" =>
          Return.transforming(els)(e => code"if($cond)$thn else $e")
        case code"(${Const(n)}:Int)" => Const(n+1)
      }
      b eqt code"println; println(if(true) println(42.toDouble) else println(667.toDouble))"
    }
    
    {
      val a = code"println; if(readInt>0) println(42.toDouble,true) else println(666.toDouble,true); println(true)"
      val b = a rewrite {
        case code"true" => code"false"
        case code"if(readInt>0)$thn else $els: $t" =>
          Return.transforming(els)(e => code"if(true) $e else $thn")
        case code"(${Const(n)}:Int)" => Const(n+1)
      }
      b eqt code"println; if(true) println(667.toDouble,false) else println(42.toDouble,true); println(false)"
    }
    
    // Simpler example:
    {
      //val a = ir"readDouble; print(true.toString); readInt; println(true)"
      val a = code"readDouble; print(true.toString); val x = readInt; if (true) println(x)"
      val b = a rewrite {
        case code"true" => code"false"
        //case ir"print($x)" => // does not produce several statements, so does not trigger the case we're testing
        case code"print(($x:Boolean).toString)" =>
          Return.transforming(x)(x => code"print($x)")
      }
      //b eqt ir"readDouble; print(false); readInt; println(false)"
      b eqt code"readDouble; print(false); val x = readInt; if (false) println(x)"
    }
    
  }
  
  
  test("Predef.Return.recursing") {
    
    def f(x: Code[_,{}]) = x rewrite {
      case code"val x: Int = $init; readInt+1; $body: $bt" =>
        Return.recursing { tr => val b = tr(body); code"val x: Int = $init; readInt; $b" }
      case code"readInt" => code"???"
    }
    code"readInt; val n = readInt; readInt+1; readInt; print(n)" |> f eqt 
      code"???; val n = readInt; readInt; ???; print(n)"
    
    def g(x: Code[_,{}]) = x  rewrite {
      case code"val x: Int = $init; readInt; $body: $bt" =>
        Return.recursing { tr => val b = tr(body); code"val x: Int = $init; readDouble; $b" }
      case code"readInt" => code"???"
    }
    
    // What happens: first two readInt's are matched and the rest is transformed,
    // BUT the result refers to the second readInt, which was not named, so that fails
    // Instead, the second and third readInt are matched and transformed successfully
    code"readInt; val n = readInt; readInt; readInt; print(n)" |> g eqt
      code"readInt; val n = readInt; readDouble; ???; print(n)"
    code"readInt; val n = readInt; readInt; readInt; print(n); readInt" |> g eqt
      code"readInt; val n = readInt; readDouble; ???; print(n); ??? : Int"
    
    // Note: the second `readInt` is printed... because of a nasty subtle hygiene issue, due to recursively matching with the same xtor binding!
    code"val n = readInt; readInt; readInt; readInt; print(n); readInt" |> g eqt
      code"val n = readInt; readDouble; val m = readInt; readDouble; print(m); ??? : Int"
    
    // Shorter example:
    code"val a = readInt; val b = readInt; print(a)" rewrite { case code"val x = readInt; $body: $bt" => Return.transforming(body)(body => code"val x = readDouble.toInt; $body") } eqt
    code"val a = readDouble.toInt; val b = readDouble.toInt; print(b)"
    
    // While the version with implicit recursion does not have the problem: 
    code"val a = readInt; val b = readInt; print(a)" rewrite { case code"val x = readInt; $body: $bt" => code"val x = readDouble.toInt; $body" } eqt
    code"val a = readDouble.toInt; val b = readDouble.toInt; print(a)"
    
  }
  
  test("Context Enlargement") {
    
    var r = code"lol?:Double; List[Int]()"
    
    r = code"List[Int](readInt)" rewrite {
      case code"readInt" =>
        Return(code"(lol? : Double).toInt")
        code"???"
    }
    
    assertDoesNotCompile("""
    r = code"List[Int](readInt)" rewrite {
      case code"readInt" =>
        Return(code"(nope? : Double).toInt")
        code"???"
    }
    """) // Error:(126, 32) type mismatch; found: squid.anf.SimpleANFTests.DSL.IR[List[Int],Any{val nope: Double}]; required: TransformationControlTests.this.DSL.IR[List[Int],Any{val lol: Double}]
    
    r eqt code"List[Int]((lol? : Double).toInt)"
    
  }
  
  test("Bad Return Type") {
    
    assertDoesNotCompile("""
    code"List[Int](readInt)" rewrite { case code"readInt" => Return(code"readDouble"); code"???" }
    """) // Error:(140, 58) Cannot rewrite a term of type Int to a different type Double
    
  }
  
  
  test("Abort and Return in pattern guard") { // FIXME
    
    /*
    ir"List[Int](readInt)" rewrite {
      case ir"readInt" if {Return(ir"42"); true} => ir"???"
    } eqt ir"List[Int](42)"
    
    ir"List[Int](readInt)" rewrite {
      case ir"readInt" if Abort() => ir"???"
    } eqt ir"List[Int](readInt)"
    */
    
    // TODO (test nested RwR)
    
  }
  
  
  test("Early Return in Middle of Block") {
    
    val c0 = code"print(1); print(2); print(3); print(4)"
    val c1 = c0 rewrite {
      case code"print(2); print(3)" =>
        Return(code"print(23)")
    }
    c1 eqt code"print(1); print(23); print(4)"
    
    val a = code"val aaa = readInt; val bbb = readDouble.toInt; (aaa+bbb).toDouble"
    val b = a rewrite {
      case code"readDouble.toInt" =>
        Return(code"readInt")
    }
    b eqt code"val aa = readInt; val bb = readInt; (aa+bb).toDouble"
    
  }
  
  
  
}
